#pragma config(Sensor, S1,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     Colour,         sensorEV3_Color)
#pragma config(Motor,  motorB,          Left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          Right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorA,          Lift,          tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Moves Forward until it is dist cm in front of a wall
void untilWall(int dist){
	while(SensorValue(Sonar) > dist)	{
		motor[Left] = 20;
		motor[Right] = 20;
	}
	motor[Left] = 0;
	motor[Right] = 0;

}

//Moves forward cm centimetres
void moveForward (int cm) {
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	int dist = cm*(2500/123);

	motor[Left]= 20;
	motor[Right]= 20;

	while(nMotorEncoder[Left] < dist || nMotorEncoder[Right] < dist){}
	motor[Left] = 0;
	motor[Right] = 0;
}

//Turns right x degrees
//Did some tests with encoders and found multiplying by 93/45 gave us the correct angle to turn
void turnRight(int x) {
	//Reset encoders`
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	//Perform a point turn to the left. We will use lower power values for more accuracy.
	motor[Left] = 20;
	motor[Right] = -20;

	int Angle = x*(93/45);

	//Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
	//we need to test both encoders and control both motors separately. This may result in one motor
	//going for longer than another but it will ultimately result in a much more accurate turn.
	while(nMotorEncoder[Right] < -Angle || nMotorEncoder[Left] > Angle) {
		if(nMotorEncoder[Right] > -Angle) {motor[Right] = 0;}
		if(nMotorEncoder[Left] < Angle) {motor[Left] = 0;}
	}
}

//Turns left x degrees
//Did some tests with encoders and found multiplying by 93/45 gave us the correct angle to turn
void turnLeft(int x) {
	//Reset encoders`
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	//Perform a point turn to the left. We will use lower power values for more accuracy.
	motor[Left] = -20;
	motor[Right] = 20;

	int Angle = x*(93/45);

	//Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
	//we need to test both encoders and control both motors separately. This may result in one motor
	//going for longer than another but it will ultimately result in a much more accurate turn.
	while(nMotorEncoder[Right] < Angle || nMotorEncoder[Left] > -Angle) {
		if(nMotorEncoder[Right] > Angle) {motor[Right] = 0;}
		if(nMotorEncoder[Left] < -Angle) {motor[Left] = 0;}
	}
}

void WalledRoom() {
	while (SensorValue[Sonar]	< 7){
		moveForward();
	}

	turnRight(90);

	while (SensorValue[Sonar]	< 7){
		moveForward();
	}

	turnLeft(90);

	while (SensorValue[Sonar]	< 7){
		moveForward();
	}

	turnRight();

	moveForward();
	wait1Msec(1000);
}

void FireRoom() {
	while(SensorValue[Sonar] < 15){
		motor[Left] = -30;
		motor[Right] = -30;
	}

	turnRight(180);

	motor[Left] = -30;
	motor[Right] = -30;
	wait1Msec(2000);

	turnLeft(90);
	moveForward();
	wait1Msec(2000);
}

void SurviorRoom() {
	while(SensorValue[Sonar] > 13){
		moveForward();
	}


	motor[Left] = 0;
	motor[Right] = 0;

	motor[Lift] = -10;
	wait1Msec(1400);

	moveForward();
	wait1Msec(550);
	motor[Left] = 0;
	motor[Right] = 0;

	motor[Lift] = 10;
	wait1Msec(1400);

	moveForward();
	wait1Msec(1000);
}

void EmptyRoom() {
	while(SensorValue[Sonar] > 7){
		moveForward();
	}

	turnRight(90);

	moveForward();
	wait1Msec(3000);
}

boolean detectWalledRoom() {
		int frontDistance, backDistance;
		frontDistance = SensorValue[Sonar];
		wait1Msec(2000); //Wait 2 seconds
		turnRight(180);
		backDistance = SensorValue[Sonar];
		wait1Msec(2000);//Wait 2 seconds
		turnLeft(180);
		return(frontDistance < backDistance);
}


task main(){
	int WallDistance = 20;
	int room = 0;

	motor[Lift] = 10;
	wait1Msec(1500);

	while(room<4){
		if(detectWalledRoom()){
			WalledRoom();
		}
		else{
			//Move Forward Slightly to get ready to check for survivor
			moveForward();
			wait1Msec(2000);
			//Had to double the amount to turn at half the speed for a more accurate sonar reading.
			int SurvivorDegrees = 130*(93/45)*2;
			//Any large value just as a starting point
			int LowestDistance = 30000;

			motor[Left] = -10;
			motor[Right] = 10;

			//Use Encoders here to turn to around 130 degrees
			while(nMotorEncoder[Right] < -SurvivorDegrees || nMotorEncoder[Left] > SurvivorDegrees) {
				if(nMotorEncoder[Right] > -SurvivorDegrees) {motor[Right] = 0;}
				if(nMotorEncoder[Left] < SurvivorDegrees) {motor[Left] = 0;}

				if(SensorValue(Sonar) < LowestDistance){
					LowestDistance = SensorValue(Sonar);
				}
			}

			//SurvivorDistance is the distance we would expect the survivor to be at
			int SurvivorDistance = 10;
			//If the distance is closer than we would expect in a clear room, we must have picked up the survivor with the sonar
			if(LowestDistance<SurvivorDistance){
				while(SensorValue(Sonar)>LowestDistance){
					motor[Left] = 10;
					motor[Right] = -10;
				}
				SurviorRoom();
			}

			else{
				turnLeft(130);

				clearTimer(T1);
				bool isFireRoom = false;

				while(time1[T1] < 3000){
					motor[Left] = 20;
					motor[Right] = 20;

					if(SensorValue(Colour) == 5){
						isFireRoom = true;
						break;
					}
				}

				if(isFireRoom == true) {
					FireRoom();
				}
				else{
					EmptyRoom();
				}
			}
		}
		room++;
	}
}