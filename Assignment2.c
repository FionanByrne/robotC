#pragma config(Sensor, S2,     Colour,         sensorEV3_Color)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          Lift,          tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          Left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          Right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Moves Forward until it is dist cm in front of a wall
void untilWall(int dist){
	while(SensorValue(Sonar) > dist)	{
		motor[Left] = 20;
		motor[Right] = 20;
	}
	motor[Left] = 0;
	motor[Right] = 0;
}

void resetMotors () {
	motor[Left] = 0;
	motor[Right] = 0;
}

//Moves forward cm centimetres
void moveForward (int cm) {
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	int dist = cm*(2500/123);

	motor[Left]= 20;
	motor[Right]= 20;

	while(nMotorEncoder[Left] < dist || nMotorEncoder[Right] < dist){}
	resetMotors();
}

//Turns right x degrees
//Did some tests with encoders and found multiplying by 2 gave us the correct angle to turn
void turnRight(int x) {
	//Reset encoders`
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	//Perform a point turn to the right. We will use lower power values for more accuracy.
	motor[Left] = 20;
	motor[Right] = -20;

	int Angle = x*(90/45);

	//Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
	//we need to test both encoders and control both motors separately. This may result in one motor
	//going for longer than another but it will ultimately result in a much more accurate turn.

	while(nMotorEncoder[Right] > -Angle || nMotorEncoder[Left] < Angle) {
		if(nMotorEncoder[Right] < -Angle) {motor[Right] = 0;}
		if(nMotorEncoder[Left] > Angle) {motor[Left] = 0;}
	}

	resetMotors();
}

//Turns left x degrees
//Did some tests with encoders and found multiplying by 2 gave us the correct angle to turn
void turnLeft(int x) {
	//Reset encoders`
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	//Perform a point turn to the left. We will use lower power values for more accuracy.
	motor[Left] = -20;
	motor[Right] = 20;

	int Angle = x*(90/45);

	//Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
	//we need to test both encoders and control both motors separately. This may result in one motor
	//going for longer than another but it will ultimately result in a much more accurate turn.

	while(nMotorEncoder[Left] > -Angle || nMotorEncoder[Right] < Angle) {
		if(nMotorEncoder[Left] < -Angle) {motor[Left] = 0;}
		if(nMotorEncoder[Right] > Angle) {motor[Right] = 0;}
	}

	resetMotors();
}

void WalledRoom() {
	writeDebugStream("WalledRoom->");
	untilWall(7);

	turnRight(90);

	moveForward(10);

	turnLeft(90);

	untilWall(7);

	turnRight(90);

	moveForward(2);
}

void FireRoom() {
	while(SensorValue[Sonar] < 15){
		motor[Left] = -30;
		motor[Right] = -30;
	}

	turnRight(180);

	motor[Left] = -30;
	motor[Right] = -30;
	wait1Msec(2000);

	turnLeft(90);
	moveForward(4);
}

void SurviorRoom() {
	untilWall(13);


	motor[Left] = 0;
	motor[Right] = 0;

	motor[Lift] = -10;
	wait1Msec(1400);

	moveForward(2);
	motor[Left] = 0;
	motor[Right] = 0;

	motor[Lift] = 10;
	wait1Msec(1400);

	moveForward(4);
}

void EmptyRoom() {
	untilWall(7);

	//Sets the sound volume of the EV3 speaker to 100
	setSoundVolume(100);
	//Play the sound file analyze
	playSoundFile("Analyze");
	// Gives the file 2 seconds to play
	sleep(2000);

	turnRight(90);

	moveForward(8);
}


bool detectWalledRoom() {
	writeDebugStream("DetectWalledRoom->");

		int frontDistance = SensorValue(Sonar);
		wait1Msec(1000); //Wait 1 seconds
		turnRight(180);
		int backDistance = SensorValue(Sonar);
		wait1Msec(1000);//Wait 1 seconds
		turnLeft(180);
		writeDebugStream("front: %d, back: %d->", frontDistance, backDistance);
		return(frontDistance < backDistance);
}


task main(){
	int i = 0;

	motor[Lift] = 10;

	while(i<4){
	writeDebugStream("Start->");
		//If the distance is less than the expected distance to a wall
		//we must be in the walled room
		if(detectWalledRoom()){
			WalledRoom();
		}
		/*
		else{
			//If we are not in the walled room we can check for the other rooms
			//Move Forward Slightly to get ready to check for survivorRooom
			moveForward(4);
			//Had to double the amount to turn at half the speed for a more accurate sonar reading.
			int SurvivorDegrees = 130*(2)*2;
			//Any large value just as a starting point
			int LowestDistance = 30000;

			motor[Left] = -10;
			motor[Right] = 10;

			//Use Encoders here to turn to around 130 degrees
			//Here we are checking if at any point the distance is less than we would expect it to be
			//If this is true the unexpected distance must be the survivor
			//We aren't able to use the normal turn left function here as we need to run a test for
			//checking the lowest distance while in the loop to update the encoders
			while(nMotorEncoder[Right] < -SurvivorDegrees || nMotorEncoder[Left] > SurvivorDegrees) {
				if(nMotorEncoder[Right] > -SurvivorDegrees) {motor[Right] = 0;}
				if(nMotorEncoder[Left] < SurvivorDegrees) {motor[Left] = 0;}

				if(SensorValue(Sonar) < LowestDistance){
					LowestDistance = SensorValue(Sonar);
				}
			}

			//SurvivorDistance is the distance we would expect the survivor to be at
			int SurvivorDistance = 10;
			//If the distance is closer than we would expect in a clear room, we must have picked up the survivor with the sonar
			if(LowestDistance<SurvivorDistance){
				while(SensorValue(Sonar)>LowestDistance){
					motor[Left] = 10;
					motor[Right] = -10;
				}
				SurviorRoom();
			}

			else{
				//If we aren't in the survivor room, we turn back 130 so we face straight again
				turnLeft(130);

				clearTimer(T1);
				bool isFireRoom = false;

				//Here we check if it is the fire room or not
				//We go forward for 3s, if at any point the light sensor picks up red
				//The robot stop s moving forward and runs the FireRoom function
				//If the robot doesnt pick up red, we know we are in the empty room and run that function
				while(time1[T1] < 3000){
					motor[Left] = 20;
					motor[Right] = 20;

					if(SensorValue(Colour) == 5){
						isFireRoom = true;
						break;
					}
				}

				if(isFireRoom == true) {
					FireRoom();
				}
				else{
					EmptyRoom();
				}
			}
		}
		*/
		i++;
	}
}
