#pragma config(Sensor, S3,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     Sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          Lift,          tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          Left,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          Right,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Moves Forward until it is dist cm in front of a wall
void untilWall(int dist){
	while(SensorValue(Sonar) > dist)	{
		motor[Left] = 20;
		motor[Right] = 20;
	}
	motor[Left] = 0;
	motor[Right] = 0;
}

void resetMotors () {
	motor[Left] = 0;
	motor[Right] = 0;
}

//Moves forward cm centimetres
void moveForward (int cm) {
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	int dist = cm*(2500/118);

	motor[Left]= 20;
	motor[Right]= 20;

	while(nMotorEncoder[Left] < dist || nMotorEncoder[Right] < dist){}
	resetMotors();
}

//Turns right x degrees
//Did some tests with encoders and found multiplying by 2 gave us the correct angle to turn
void turnRight(int x) {
	//Reset encoders`
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	//Perform a point turn to the right. We will use lower power values for more accuracy.
	motor[Left] = 20;
	motor[Right] = -20;

	int Angle = x*(90/45);

	//Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
	//we need to test both encoders and control both motors separately. This may result in one motor
	//going for longer than another but it will ultimately result in a much more accurate turn.

	while(nMotorEncoder[Right] > -Angle || nMotorEncoder[Left] < Angle) {
		if(nMotorEncoder[Right] < -Angle) {motor[Right] = 0;}
		if(nMotorEncoder[Left] > Angle) {motor[Left] = 0;}
	}

	resetMotors();
}

//Turns left x degrees
//Did some tests with encoders and found multiplying by 2 gave us the correct angle to turn
void turnLeft(int x) {
	//Reset encoders`
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	//Perform a point turn to the left. We will use lower power values for more accuracy.
	motor[Left] = -20;
	motor[Right] = 20;

	int Angle = x*(90/45);

	//Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
	//we need to test both encoders and control both motors separately. This may result in one motor
	//going for longer than another but it will ultimately result in a much more accurate turn.

	while(nMotorEncoder[Left] > -Angle || nMotorEncoder[Right] < Angle) {
		if(nMotorEncoder[Left] < -Angle) {motor[Left] = 0;}
		if(nMotorEncoder[Right] > Angle) {motor[Right] = 0;}
	}

	resetMotors();
}

void WalledRoom() {
	writeDebugStream("WalledRoom->");
	untilWall(7);

	turnRight(90);

	moveForward(20);

	turnLeft(90);

	untilWall(7);

	turnRight(90);
}

void SurvivorRoom() {
	int SurvivorDegrees = 130*(2);
	//Any large value just as a starting point
	int LowestDistance = 30000;

	//Reset encoders
	nMotorEncoder[Left] = 0;
	nMotorEncoder[Right] = 0;

	//Perform a point turn to the right. We will use lower power values for more accuracy.
	motor[Left] = 10;
	motor[Right] = -10;

	//Use Encoders here to turn to around 130 degrees
	//Here we are checking if at any point the distance is less than we would expect it to be
	//If this is true the unexpected distance must be the survivor
	//We aren't able to use the normal turn left function here as we need to run a test for
	//checking the lowest distance while in the loop to update the encoders
	while(nMotorEncoder[Right] > -SurvivorDegrees || nMotorEncoder[Left] < SurvivorDegrees) {
		if(nMotorEncoder[Right] < -SurvivorDegrees) {motor[Right] = 0;}
		if(nMotorEncoder[Left] > SurvivorDegrees) {motor[Left] = 0;}

		if(SensorValue(Sonar) < LowestDistance){
			LowestDistance = SensorValue(Sonar);
		}
	}

	resetMotors();

	//Turn until we see the survivor again
	while(SensorValue(Sonar)>=LowestDistance){
		motor[Left] = -10;
		motor[Right] = 10;
	}

	writeDebugStream("SurvivorRoom->");
	untilWall(13);

	motor[Left] = 0;
	motor[Right] = 0;

	motor[Lift] = -10;
	wait1Msec(1400);

	moveForward(4);
	motor[Left] = 0;
	motor[Right] = 0;

	motor[Lift] = 10;
	wait1Msec(1400);

	moveForward(8);
}

void FireRoom() {
	writeDebugStream("FireRoom->");
	while(SensorValue[Sonar] < 15){
		motor[Left] = -30;
		motor[Right] = -30;
	}

	turnRight(180);

	motor[Left] = -30;
	motor[Right] = -30;
	wait1Msec(2000);

	turnLeft(90);
	moveForward(4);
}

void EmptyRoom() {
	untilWall(7);

	//Sets the sound volume of the EV3 speaker to 100
	setSoundVolume(100);
	//Play the sound file analyze
	playSoundFile("Analyze");
	// Gives the file 2 seconds to play
	sleep(2000);

	turnRight(90);

	moveForward(8);
}


bool detectWalledRoom() {
	writeDebugStream("DetectWalledRoom->");

	moveForward(20);
	wait1Msec(1000); //Wait 1 seconds
	int frontDistance = SensorValue(Sonar);
	writeDebugStream("front: %d ->", frontDistance);
	return(frontDistance < 24);
}


task main(){
	int i = 0;

	motor[Lift] = 10;

	while(i<4){
		writeDebugStream("Start->");
		//If the distance is less than the expected distance to a wall
		//we must be in the walled room
		if(detectWalledRoom()){
			WalledRoom();
		}
		else {
			//If we are not in the walled room we can check for the other room
			clearTimer(T1);
			bool isFireRoom = false;

			//Here we check if it is the fire room or not
			//We go forward for 3s, if at any point the light sensor picks up red
			//The robot stops moving forward and runs the FireRoom function
			//If the robot doesnt pick up red, we know we check for the remaining 2 rooms
			while(time1[T1] < 2000){
				motor[Left] = 20;
				motor[Right] = 20;

				if(SensorValue(Colour) == 5){
					isFireRoom = true;
					break;
					writeDebugStream("FoundFireRoom->");
				}
			}

			if(isFireRoom == true) {
				FireRoom();
			}
			else{
				if(SensorValue(Sonar) < 20){
						SurvivorRoom();
				}
				else{
					EmptyRoom();
				}
			}
		}
		i++;
	}
}
